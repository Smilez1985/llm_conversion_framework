#!/usr/bin/env python3
"""
LLM Cross-Compiler Framework - Module Generator (Core Logic)
DIREKTIVE: Goldstandard, Separation of Concerns.

Zweck:
Zentrale Logik zur Generierung neuer Hardware-Target-Module.
Wird sowohl von der GUI (Wizard) als auch der CLI (Command) genutzt.
"""

import os
from pathlib import Path
from typing import Dict, List, Any
import yaml

from orchestrator.utils.logging import get_logger
from orchestrator.utils.helpers import ensure_directory

class ModuleGenerator:
    """Generates file structure and content for new hardware targets."""
    
    def __init__(self, targets_dir: Path):
        self.logger = get_logger(__name__)
        self.targets_dir = targets_dir

    def generate_module(self, data: Dict[str, Any]) -> Path:
        """
        Generate a complete module from configuration data.
        """
        module_slug = data["module_name"].lower().replace(" ", "_")
        target_dir = self.targets_dir / module_slug
        
        self.logger.info(f"Generating new target module: {data['module_name']} at {target_dir}")
        
        # 1. Create Directory Structure
        ensure_directory(target_dir)
        ensure_directory(target_dir / "modules")
        ensure_directory(target_dir / "scripts")
        
        # 2. Generate Files
        self._write_dockerfile(target_dir, data)
        self._write_target_yml(target_dir, data)
        self._write_config_module(target_dir, data)
        self._write_profile_script(target_dir, data)
        
        # NEU: Generiere das intelligente Build-Skript (statt nur Platzhalter)
        self._write_build_script(target_dir, data)
        
        # 3. Create Placeholder Modules (Standardized)
        self._write_standard_modules(target_dir)
        
        self.logger.info("Module generation completed successfully.")
        return target_dir

    def _write_dockerfile(self, target_dir: Path, data: Dict[str, Any]):
        """Generate Dockerfile content"""
        packages_str = " \\\n        ".join(data.get("packages", []))
        
        content = f'''# Dockerfile for {data["module_name"]}
# Generated by LLM Cross-Compiler Framework
# Target Architecture: {data["architecture"]}

FROM {data["base_os"]} AS builder

# Metadata
LABEL maintainer="Community Contributor"
LABEL description="{data.get("description", "")}"
LABEL target.architecture="{data["architecture"]}"
LABEL target.sdk="{data["sdk"]}"

# Environment
ENV DEBIAN_FRONTEND=noninteractive
ENV LLAMA_CPP_PATH=/usr/src/llama.cpp
ENV BUILD_CACHE_DIR=/build-cache

# System dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
        {packages_str} \\
    && rm -rf /var/lib/apt/lists/*

# Additional setup commands
{data.get("setup_commands", "# No additional setup commands")}

# Copy framework modules
WORKDIR /app
COPY modules/ ./modules/
RUN chmod +x modules/*.sh

# Set working directory
WORKDIR ${{BUILD_CACHE_DIR}}

# Default entrypoint
COPY docker/entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
CMD ["interactive"]
'''
        with open(target_dir / "Dockerfile", "w") as f:
            f.write(content)

    def _write_target_yml(self, target_dir: Path, data: Dict[str, Any]):
        """Generate target.yml configuration"""
        config = {
            "metadata": {
                "name": data["module_name"],
                "description": data.get("description", ""),
                "maintainer": "Community Contributor",
                "version": "1.0.0",
                "architecture": data["architecture"],
                "sdk": data["sdk"]
            },
            "supported_boards": data.get("supported_boards", []),
            "docker": {
                "image_name": f"llm-framework/{data['module_name'].lower().replace(' ', '-')}",
                "build_context": ".",
                "dockerfile": "Dockerfile"
            },
            "modules": {
                "source": "modules/source_module.sh",
                "config": "modules/config_module.sh",
                "convert": "modules/convert_module.sh",
                "build": "modules/build.sh", # NEU: Verweis auf build.sh
                "target": "modules/target_module.sh"
            }
        }
        
        with open(target_dir / "target.yml", "w") as f:
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    def _write_config_module(self, target_dir: Path, data: Dict[str, Any]):
        """Generate config_module.sh"""
        # Architecture specific compiler settings
        compiler_settings = ""
        if data["architecture"] == "aarch64":
            compiler_settings = '''
# Cross-compilation for AArch64
SET(CMAKE_C_COMPILER   /usr/bin/aarch64-linux-gnu-gcc)
SET(CMAKE_CXX_COMPILER /usr/bin/aarch64-linux-gnu-g++)
'''
        
        content = f'''#!/bin/bash
# config_module.sh for {data["module_name"]}
# Generated by LLM Cross-Compiler Framework

set -euo pipefail

# Configuration
readonly BUILD_CACHE_DIR="${{BUILD_CACHE_DIR:-/build-cache}}"
readonly HARDWARE_CONFIG_FILE="${{BUILD_CACHE_DIR}}/target_hardware_config.txt"
readonly CMAKE_TOOLCHAIN_FILE="${{BUILD_CACHE_DIR}}/cross_compile_toolchain.cmake"

# Generate CMake toolchain
generate_cmake_toolchain() {{
    echo "Generating CMake toolchain for {data['architecture']}"
    
    cat > "$CMAKE_TOOLCHAIN_FILE" << 'EOF'
# Generated CMake Toolchain
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_PROCESSOR {data["architecture"]})

{compiler_settings}

# Compiler flags
SET(CMAKE_C_FLAGS "${{CMAKE_C_FLAGS}} {data.get("optimization_level", "-O3")} {data.get("cpu_flags", "")}")
SET(CMAKE_CXX_FLAGS "${{CMAKE_CXX_FLAGS}} {data.get("optimization_level", "-O3")} {data.get("cpu_flags", "")} -std=c++17")

# SDK-specific flags
{data.get("cmake_flags", "")}

EOF
}}

main() {{
    echo "Configuring {data['module_name']}..."
    generate_cmake_toolchain
}}

main "$@"
'''
        self._write_script(target_dir / "modules" / "config_module.sh", content)

    def _write_build_script(self, target_dir: Path, data: Dict[str, Any]):
        """
        NEU: Generiert das intelligente build.sh Skript.
        Hier landet die Logik von Ditto (oder der Default-Case).
        """
        quant_logic = data.get("quantization_logic", "")
        if not quant_logic:
            # Fallback Default Logic
            quant_logic = """
    "FP16")
        echo ">> Default FP16 Build (No Quantization)"
        # Standard build commands would go here
        ;;
    *)
        echo ">> Unknown Quantization: $QUANT_TYPE"
        ;;
"""

        content = f'''#!/bin/bash
# build.sh for {data["module_name"]}
# Generated by LLM Cross-Compiler Framework (Ditto/Wizard)
#
# Environment Variables:
# $MODEL_SOURCE, $QUANTIZATION, $OUTPUT_DIR

set -euo pipefail

WORK_DIR="${{BUILD_CACHE_DIR:-/build-cache}}"
OUTPUT_DIR="${{WORK_DIR}}/output"
mkdir -p "$OUTPUT_DIR"

echo "=== Build Started: {data['module_name']} ==="
echo "Quantization: ${{QUANTIZATION:-None}}"

QUANT_TYPE="${{QUANTIZATION:-FP16}}"

case "$QUANT_TYPE" in
{quant_logic}
esac

echo "=== Build Completed ==="
'''
        self._write_script(target_dir / "modules" / "build.sh", content)


    def _write_profile_script(self, target_dir: Path, data: Dict[str, Any]):
        """Generate generate_profile.sh"""
        content = f'''#!/bin/bash
# Hardware Profile Generator for {data["module_name"]}
# Run on target hardware

OUTPUT_FILE="target_hardware_config.txt"
echo "# Profile for {data['module_name']}" > "$OUTPUT_FILE"

# Custom Detection
{data.get("detection_commands", "")}

echo "Generated $OUTPUT_FILE"
'''
        self._write_script(target_dir / "generate_profile.sh", content)

    def _write_standard_modules(self, target_dir: Path):
        """Write standard templates for other modules"""
        # Source Module (Standard)
        source_content = '''#!/bin/bash
# source_module.sh (Standard Template)
# Uses injected environment variables for repositories

set -euo pipefail
readonly BUILD_CACHE_DIR="${BUILD_CACHE_DIR:-/build-cache}"
# Standard source setup logic would go here...
# (In a real scenario, this might copy the robust template we built earlier)
echo "Source module template initialized"
'''
        self._write_script(target_dir / "modules" / "source_module.sh", source_content)
        
        # Convert Module (Platzhalter)
        self._write_script(target_dir / "modules" / "convert_module.sh", "#!/bin/bash\n# Convert Module Template\necho 'Convert module placeholder'")
        
        # Target Module (Platzhalter)
        self._write_script(target_dir / "modules" / "target_module.sh", "#!/bin/bash\n# Target Module Template\necho 'Target module placeholder'")

    def _write_script(self, path: Path, content: str):
        """Write content to file and make executable"""
        with open(path, "w") as f:
            f.write(content)
        try:
            os.chmod(path, 0o755)
        except:
            pass
