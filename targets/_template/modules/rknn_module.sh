#!/bin/bash
# rknn_module.sh Template
# Generated by LLM Cross-Compiler Framework
#
# ZWECK: Produktionsreifer Wrapper für die RKNN-Toolkit2 Python-API.
# Führt Quantisierung und Konvertierung (ONNX -> RKNN) durch.

set -euo pipefail

# ============================================================================
# ENVIRONMENT & CONFIGURATION
# ============================================================================

# Diese Variablen kommen vom Builder / Docker-Container
MODEL_SOURCE="${MODEL_SOURCE:-}"
QUANTIZATION="${QUANTIZATION:-i8}"
BUILD_CACHE_DIR="${BUILD_CACHE_DIR:-/build-cache}"
OUTPUT_DIR="${OUTPUT_DIR:-${BUILD_CACHE_DIR}/output}"
SCRIPT_DIR="/app/scripts"
RKNN_TOOLKIT_DIR="/app/rknn-toolkit2"

# Logging
log_info() { echo ">> [RKNN-Module] $(date '+%H:%M:%S') INFO: $1"; }
log_error() { echo ">> [RKNN-Module] $(date '+%H:%M:%S') ERROR: $1" >&2; }
die() { log_error "$1"; exit 1; }

# ============================================================================
# MAIN PIPELINE
# ============================================================================

main() {
    log_info "Initializing RKNN Conversion Pipeline..."

    # 1. Input Validierung
    if [[ -z "$MODEL_SOURCE" || "$MODEL_SOURCE" == "none" ]]; then
        log_info "No model source provided. Nothing to do."
        exit 0
    fi

    if [[ ! -f "$MODEL_SOURCE" ]]; then
        # RKNN benötigt meist eine einzelne Datei (ONNX), kein Verzeichnis (wie HF)
        # Falls Verzeichnis, suchen wir die .onnx Datei
        if [[ -d "$MODEL_SOURCE" ]]; then
            log_info "Searching for ONNX file in directory: $MODEL_SOURCE"
            FOUND_ONNX=$(find "$MODEL_SOURCE" -name "*.onnx" | head -n 1)
            if [[ -n "$FOUND_ONNX" ]]; then
                MODEL_SOURCE="$FOUND_ONNX"
                log_info "Found model: $MODEL_SOURCE"
            else
                die "No .onnx file found in $MODEL_SOURCE"
            fi
        else
            die "Model source not found: $MODEL_SOURCE"
        fi
    fi

    # 2. Quantisierung Mapping (Framework -> RKNN SDK)
    case "${QUANTIZATION}" in
        "INT8"|"i8"|"Q8_0"|"w8a8")
            Q_TYPE="i8"
            ;;
        "FP16"|"f16")
            Q_TYPE="fp16"
            ;;
        *)
            log_info "Unknown quantization '$QUANTIZATION'. Defaulting to 'i8' (INT8)."
            Q_TYPE="i8"
            ;;
    esac

    # 3. Target Platform (Fallback wenn nicht gesetzt)
    # Kann via Env TARGET_BOARD=rk3588 gesetzt sein
    TARGET_PLATFORM="${TARGET_BOARD:-rk3566}"
    # Bereinigung des Strings (rknn config ist strikt)
    if [[ "$TARGET_PLATFORM" == *"3588"* ]]; then TARGET_PLATFORM="rk3588"; fi
    if [[ "$TARGET_PLATFORM" == *"3566"* ]]; then TARGET_PLATFORM="rk3566"; fi

    # 4. Python Converter Aufruf
    CONVERTER="$SCRIPT_DIR/rknn_converter.py"
    
    if [[ ! -f "$CONVERTER" ]]; then
        die "Python converter script missing at $CONVERTER. Check Dockerfile COPY."
    fi

    # Output Dateiname generieren
    MODEL_NAME=$(basename "$MODEL_SOURCE" .onnx)
    OUTPUT_FILE="$OUTPUT_DIR/${MODEL_NAME}_${TARGET_PLATFORM}_${Q_TYPE}.rknn"

    log_info "------------------------------------------------"
    log_info "Config:"
    log_info "  Model:    $MODEL_SOURCE"
    log_info "  Output:   $OUTPUT_FILE"
    log_info "  Target:   $TARGET_PLATFORM"
    log_info "  Quant:    $Q_TYPE"
    log_info "------------------------------------------------"

    # Start Python Process
    set +e
    python3 "$CONVERTER" \
        --model "$MODEL_SOURCE" \
        --output "$OUTPUT_FILE" \
        --target "$TARGET_PLATFORM" \
        --dtype "$Q_TYPE"
    
    EXIT_CODE=$?
    set -e

    # 5. Abschluss-Prüfung
    if [ $EXIT_CODE -eq 0 ]; then
        if [ -f "$OUTPUT_FILE" ]; then
            SIZE=$(du -h "$OUTPUT_FILE" | cut -f1)
            log_info "✅ Success! Artifact: $OUTPUT_FILE ($SIZE)"
        else
            die "Python script finished without error, but output file is missing."
        fi
    else
        die "Python conversion failed with exit code $EXIT_CODE."
    fi
}

main "$@"
