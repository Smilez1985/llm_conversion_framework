#!/usr/bin/env python3
"""
LLM Cross-Compiler Framework - Wizards
DIREKTIVE: Goldstandard, vollst√§ndige Implementierung.
"""

import threading
import re
from pathlib import Path
from PySide6.QtWidgets import (
    QWizard, QWizardPage, QVBoxLayout, QLabel, QFormLayout, 
    QLineEdit, QComboBox, QRadioButton, QButtonGroup, QTextEdit, 
    QMessageBox, QGroupBox, QPushButton, QFileDialog, QProgressBar,
    QDialog, QHBoxLayout
)
from PySide6.QtCore import Qt, Signal, QObject

from orchestrator.Core.module_generator import ModuleGenerator
from orchestrator.gui.dialogs import AIConfigurationDialog

try:
    from orchestrator.Core.ditto_manager import DittoCoder
except ImportError:
    DittoCoder = None

class WizardSignals(QObject):
    """Signale f√ºr Thread-Kommunikation"""
    analysis_finished = Signal(dict)
    analysis_error = Signal(str)

class ModuleCreationWizard(QWizard):
    """
    5-Step Module Creation Wizard mit Dual-Mode (Standard & AI).
    """
    
    def __init__(self, targets_dir: Path, parent=None):
        super().__init__(parent)
        self.targets_dir = targets_dir
        self.setWindowTitle("Module Creation Wizard")
        self.setWizardStyle(QWizard.ModernStyle)
        self.setMinimumSize(900, 700)
        
        self.module_data = {}
        self.ai_config = {} 
        
        self.signals = WizardSignals()
        self.signals.analysis_finished.connect(self.on_ai_finished)
        self.signals.analysis_error.connect(self.on_ai_error)
        
        # Pages hinzuf√ºgen
        self.addPage(self.create_intro_page())
        self.addPage(self.create_hardware_page())
        self.addPage(self.create_docker_page())
        self.addPage(self.create_flags_page())
        self.addPage(self.create_summary_page())

    def create_intro_page(self):
        page = QWizardPage()
        page.setTitle("Welcome")
        page.setSubTitle("Create a new Hardware Target Module")
        layout = QVBoxLayout()
        
        layout.addWidget(QLabel(
            "This wizard will guide you through creating a new hardware target.\n"
            "Please upload the 'target_hardware_config.txt' generated by hardware_probe.sh."
        ))
        
        # --- Import Section ---
        import_group = QGroupBox("üìÇ Import Hardware Probe")
        import_layout = QVBoxLayout()
        
        hbox_btns = QHBoxLayout()
        
        # Button 1: Standard Import (Hardcoded Logic)
        self.btn_import_std = QPushButton("‚ö° Standard Import (Rule-Based)")
        self.btn_import_std.clicked.connect(self.run_standard_import)
        self.btn_import_std.setToolTip("Parses the file using strict rules (No AI). Fast and deterministic.")
        hbox_btns.addWidget(self.btn_import_std)
        
        # Button 2: AI Import (Ditto)
        self.btn_import_ai = QPushButton("ü§ñ AI Auto-Discovery (Ditto)")
        self.btn_import_ai.clicked.connect(self.run_ai_analysis)
        self.btn_import_ai.setStyleSheet("background-color: #6a0dad; color: white; font-weight: bold;")
        self.btn_import_ai.setToolTip("Uses LLM to analyze hardware capabilities and suggest optimizations.")
        hbox_btns.addWidget(self.btn_import_ai)
        
        import_layout.addLayout(hbox_btns)
        
        # AI Config Button
        self.btn_configure_ai = QPushButton("‚öôÔ∏è Configure AI Agent")
        self.btn_configure_ai.clicked.connect(self.configure_ai)
        import_layout.addWidget(self.btn_configure_ai)

        # Progress & Status
        self.status_label = QLabel("Waiting for input...")
        self.status_label.setAlignment(Qt.AlignCenter)
        import_layout.addWidget(self.status_label)
        
        self.ai_progress = QProgressBar()
        self.ai_progress.setRange(0, 0) 
        self.ai_progress.setVisible(False)
        import_layout.addWidget(self.ai_progress)

        import_group.setLayout(import_layout)
        layout.addWidget(import_group)
        
        # --- Manual Section ---
        layout.addSpacing(20)
        layout.addWidget(QLabel("Or simply click 'Next' to configure everything manually."))
        
        page.setLayout(layout)
        return page

    def create_hardware_page(self):
        page = QWizardPage()
        page.setTitle("Hardware Information")
        page.setSubTitle("Define the target architecture")
        layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("e.g. NVIDIA Jetson Orin")
        layout.addRow("Module Name:", self.name_edit)
        
        self.arch_combo = QComboBox()
        self.arch_combo.addItems(["aarch64", "x86_64", "armv7l", "riscv64"])
        layout.addRow("Architecture:", self.arch_combo)
        
        self.sdk_edit = QLineEdit()
        self.sdk_edit.setPlaceholderText("e.g. CUDA, RKNN, OpenVINO")
        layout.addRow("SDK / Backend:", self.sdk_edit)
        
        page.setLayout(layout)
        page.registerField("name*", self.name_edit)
        return page

    def create_docker_page(self):
        page = QWizardPage()
        page.setTitle("Docker Environment")
        page.setSubTitle("Configure the build container")
        layout = QVBoxLayout()
        
        self.os_group = QButtonGroup(page)
        self.rad_debian = QRadioButton("Debian 12 (Bookworm) - Recommended")
        self.rad_ubuntu = QRadioButton("Ubuntu 22.04 LTS")
        self.rad_custom = QRadioButton("Custom")
        self.rad_debian.setChecked(True)
        
        self.os_group.addButton(self.rad_debian)
        self.os_group.addButton(self.rad_ubuntu)
        self.os_group.addButton(self.rad_custom)
        
        layout.addWidget(QLabel("Base OS:"))
        layout.addWidget(self.rad_debian)
        layout.addWidget(self.rad_ubuntu)
        layout.addWidget(self.rad_custom)
        
        self.custom_os_edit = QLineEdit()
        self.custom_os_edit.setPlaceholderText("e.g. nvidia/cuda:12.2-devel-ubuntu22.04")
        self.custom_os_edit.setEnabled(False)
        self.rad_custom.toggled.connect(lambda: self.custom_os_edit.setEnabled(self.rad_custom.isChecked()))
        layout.addWidget(self.custom_os_edit)
        
        layout.addWidget(QLabel("System Packages (space separated):"))
        self.packages_edit = QLineEdit()
        self.packages_edit.setText("build-essential cmake git python3-pip")
        layout.addWidget(self.packages_edit)
        
        page.setLayout(layout)
        return page

    def create_flags_page(self):
        page = QWizardPage()
        page.setTitle("Compiler Flags")
        page.setSubTitle("Set default optimization flags")
        layout = QFormLayout()
        
        self.cpu_flags = QLineEdit()
        self.cpu_flags.setPlaceholderText("-mcpu=cortex-a76 -mtune=cortex-a76")
        layout.addRow("CPU Flags:", self.cpu_flags)
        
        self.cmake_flags = QLineEdit()
        self.cmake_flags.setPlaceholderText("-DGGML_CUDA=ON")
        layout.addRow("CMake Flags:", self.cmake_flags)
        
        page.setLayout(layout)
        return page

    def create_summary_page(self):
        page = QWizardPage()
        page.setTitle("Summary & Generation")
        page.setSubTitle("Review settings before generation")
        layout = QVBoxLayout()
        
        self.summary_text = QTextEdit()
        self.summary_text.setReadOnly(True)
        layout.addWidget(self.summary_text)
        
        page.setLayout(layout)
        return page

    def initializePage(self, page_id):
        if self.nextId() == -1: # Last page
            self.update_summary()

    def update_summary(self):
        if self.rad_debian.isChecked(): base_os = "debian:bookworm-slim"
        elif self.rad_ubuntu.isChecked(): base_os = "ubuntu:22.04"
        else: base_os = self.custom_os_edit.text()
        
        summary = f"""
        [CONFIGURATION SUMMARY]
        -----------------------
        Module Name:  {self.name_edit.text()}
        Architecture: {self.arch_combo.currentText()}
        SDK Backend:  {self.sdk_edit.text()}
        
        [DOCKER]
        Base Image:   {base_os}
        Packages:     {self.packages_edit.text()}
        
        [COMPILER]
        CPU Flags:    {self.cpu_flags.text()}
        CMake Flags:  {self.cmake_flags.text()}
        """
        self.summary_text.setText(summary)

    # --- STANDARD IMPORT LOGIC (Rule Based) ---

    def run_standard_import(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Hardware Probe", "", "Text (*.txt);;All Files (*)")
        if not path: return
        
        try:
            with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read().lower()
            
            # 1. Architecture Detection
            if "aarch64" in content: self.arch_combo.setCurrentText("aarch64")
            elif "x86_64" in content: self.arch_combo.setCurrentText("x86_64")
            elif "armv7" in content: self.arch_combo.setCurrentText("armv7l")
            elif "riscv" in content: self.arch_combo.setCurrentText("riscv64")
            
            # 2. CPU Flags Extraction (Naive)
            flags = []
            if "neon" in content or "asimd" in content: flags.append("-DENABLE_NEON=ON")
            if "fp16" in content: flags.append("-DENABLE_FP16=ON")
            if "avx2" in content: flags.append("-mavx2")
            if "avx512" in content: flags.append("-mavx512f")
            
            if flags:
                self.cpu_flags.setText(" ".join(flags))
            
            # 3. SDK Hints
            sdk = "None"
            if "nvidia" in content or "cuda" in content: sdk = "CUDA"
            elif "rockchip" in content or "rknn" in content: sdk = "RKNN"
            elif "intel" in content and "npu" in content: sdk = "OpenVINO"
            self.sdk_edit.setText(sdk)
            
            # 4. Suggest Name
            self.name_edit.setText("Imported_Target")
            
            self.status_label.setText("‚úÖ Standard Import successful!")
            QMessageBox.information(self, "Import", "Probe data imported using standard rules.\nPlease review fields.")
            self.next()
            
        except Exception as e:
            QMessageBox.critical(self, "Import Error", str(e))

    # --- AI LOGIC (Ditto) ---

    def configure_ai(self):
        dialog = AIConfigurationDialog(self)
        if dialog.exec() == QDialog.Accepted:
            self.ai_config = dialog.get_config()
            self.btn_import_ai.setEnabled(True)
            self.status_label.setText(f"AI Ready: {self.ai_config.get('provider')}")

    def run_ai_analysis(self):
        if not DittoCoder:
            QMessageBox.critical(self, "Error", "Ditto/LiteLLM not installed.\nPlease run: pip install litellm")
            return
            
        if not self.ai_config:
            self.configure_ai()
            if not self.ai_config: return

        path, _ = QFileDialog.getOpenFileName(self, "Select Hardware Probe", "", "Text (*.txt);;All Files (*)")
        if not path: return
        
        self.btn_import_ai.setEnabled(False)
        self.btn_import_std.setEnabled(False)
        self.ai_progress.setVisible(True)
        self.status_label.setText("ü§ñ Ditto is thinking...")
        
        threading.Thread(target=self._ai_worker, args=(Path(path),), daemon=True).start()

    def _ai_worker(self, path):
        try:
            coder = DittoCoder(
                provider=self.ai_config.get("provider"),
                model=self.ai_config.get("model"),
                api_key=self.ai_config.get("api_key"),
                base_url=self.ai_config.get("base_url")
            )
            config = coder.generate_module_content(path)
            self.signals.analysis_finished.emit(config)
        except Exception as e:
            self.signals.analysis_error.emit(str(e))

    def on_ai_error(self, err):
        self.btn_import_ai.setEnabled(True)
        self.btn_import_std.setEnabled(True)
        self.ai_progress.setVisible(False)
        self.status_label.setText("‚ùå AI Error")
        QMessageBox.critical(self, "AI Error", err)

    def on_ai_finished(self, config):
        self.btn_import_ai.setEnabled(True)
        self.btn_import_std.setEnabled(True)
        self.ai_progress.setVisible(False)
        self.status_label.setText("‚úÖ Analysis complete!")
        
        # Populate Fields from AI
        if "module_name" in config: self.name_edit.setText(config["module_name"])
        if "architecture" in config: self.arch_combo.setCurrentText(config["architecture"])
        if "sdk" in config: self.sdk_edit.setText(config["sdk"])
        
        if "base_os" in config:
            if "debian" in config["base_os"]: self.rad_debian.setChecked(True)
            elif "ubuntu" in config["base_os"]: self.rad_ubuntu.setChecked(True)
            else:
                self.rad_custom.setChecked(True)
                self.custom_os_edit.setText(config["base_os"])
                
        if "packages" in config: self.packages_edit.setText(config["packages"])
        if "cpu_flags" in config: self.cpu_flags.setText(config["cpu_flags"])
        if "cmake_flags" in config: self.cmake_flags.setText(config["cmake_flags"])
        
        QMessageBox.information(self, "Ditto", "Values filled from AI analysis.\nPlease review on next pages.")
        self.next()

    def accept(self):
        self.module_data = {
            "module_name": self.name_edit.text(),
            "architecture": self.arch_combo.currentText(),
            "sdk": self.sdk_edit.text(),
            "description": f"Target for {self.name_edit.text()}",
            "base_os": self.custom_os_edit.text() if self.rad_custom.isChecked() else ("debian:bookworm-slim" if self.rad_debian.isChecked() else "ubuntu:22.04"),
            "packages": self.packages_edit.text().split(),
            "cpu_flags": self.cpu_flags.text(),
            "supported_boards": [],
            "setup_commands": "",
            "cmake_flags": self.cmake_flags.text(),
            "detection_commands": "lscpu"
        }
        
        try:
            if not self.targets_dir.exists(): self.targets_dir.mkdir(parents=True, exist_ok=True)
            generator = ModuleGenerator(self.targets_dir)
            output_path = generator.generate_module(self.module_data)
            QMessageBox.information(self, "Success", f"Module created at:\n{output_path}")
            super().accept()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to generate module:\n{e}")
