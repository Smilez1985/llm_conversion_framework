#!/bin/bash
# config_module.sh for [MODULE_NAME]
# Generated by LLM Cross-Compiler Framework
# ZWECK: Generiert die CMake Toolchain basierend auf Hardware-Probe.

set -euo pipefail

BUILD_CACHE_DIR="${BUILD_CACHE_DIR:-/build-cache}"
HARDWARE_CONFIG="${BUILD_CACHE_DIR}/target_hardware_config.txt"
CMAKE_TOOLCHAIN="${BUILD_CACHE_DIR}/cross_compile_toolchain.cmake"

# 1. Load Hardware Config (Source of Truth)
if [ -f "$HARDWARE_CONFIG" ]; then
    echo "Loading hardware profile from $HARDWARE_CONFIG..."
    # Sicherer Import von Key=Value Paaren (nur Gro√übuchstaben-Keys erlaubt)
    while IFS='=' read -r key value; do
        if [[ $key =~ ^[A-Z_]+$ ]]; then
            declare "$key"="$value"
        fi
    done < <(grep '=' "$HARDWARE_CONFIG")
fi

# 2. Generate CMake Toolchain
echo "Generating CMake toolchain for [IHRE_ARCHITEKTUR]..."

cat <<EOF > "$CMAKE_TOOLCHAIN"
# Generated CMake Toolchain
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_PROCESSOR [IHRE_ARCHITEKTUR])

# Compiler Flags from Wizard/Template
SET(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} [CPU_FLAGS]")
SET(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} [CPU_FLAGS]")

# --- AUTO-DETECTED OPTIMIZATIONS ---
EOF

# 3. Dynamic Feature Flags (Based on Probe SUPPORTS_*)
if [ "${SUPPORTS_NEON:-OFF}" == "ON" ]; then
    echo 'ADD_DEFINITIONS(-DGGML_NEON=ON)' >> "$CMAKE_TOOLCHAIN"
    echo ">> Auto-Enabled: NEON"
fi

if [ "${SUPPORTS_FP16:-OFF}" == "ON" ]; then
    echo 'ADD_DEFINITIONS(-DGGML_FP16=ON)' >> "$CMAKE_TOOLCHAIN"
    echo ">> Auto-Enabled: FP16"
fi

if [ "${SUPPORTS_AVX2:-OFF}" == "ON" ]; then
    echo 'ADD_DEFINITIONS(-DGGML_AVX2=ON)' >> "$CMAKE_TOOLCHAIN"
    echo ">> Auto-Enabled: AVX2"
fi

if [ "${SUPPORTS_CUDA:-OFF}" == "ON" ]; then
    echo 'ADD_DEFINITIONS(-DGGML_CUDA=ON)' >> "$CMAKE_TOOLCHAIN"
    echo ">> Auto-Enabled: CUDA"
fi

# 4. Custom CMake Flags from Wizard
echo "# Custom Flags" >> "$CMAKE_TOOLCHAIN"
echo "[CMAKE_FLAGS]" >> "$CMAKE_TOOLCHAIN"

echo "Toolchain generated at $CMAKE_TOOLCHAIN"
